@page "/account/login"




@layout Components.User.LoginLayout

@inject SignInManager<ApplicationUser> SignInManager
@inject ILogger<Login> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager
@inject ICommandHandler<LoginUser.Command,ESignInResult> LoginUserHandler

@attribute [ExcludeFromInteractiveRouting]
@attribute [AllowAnonymous]

<PageTitle>Log in</PageTitle>



<h1>Sign in to your account</h1>


<StatusMessage Message="@errorMessage" />
<EditForm Model="Input" OnValidSubmit="LoginUser" FormName="login">
    <DataAnnotationsValidator />

    <div>
        <label for="Input.Email">Email</label>
        <div>
            <InputText @bind-Value="Input.Email"
                       id="Input.Email"
                       autocomplete="username" aria-required="true" placeholder="name@example.com" />
        </div>
        <ValidationMessage For="() => Input.Email" class="mt-2 text-sm text-red-700" />
    </div>

    <div>
        <label for="Input.Password">Password</label>
        <div>
            <InputText type="password" @bind-Value="Input.Password" id="Input.Password"
                       autocomplete="current-password" aria-required="true" placeholder="password" />
        </div>
        <ValidationMessage For="() => Input.Password" class="mt-2 text-sm text-red-700" />
    </div>

    <div>

        <InputCheckbox @bind-Value="Input.RememberMe" />
        <label for="Input.RememberMe">Remember me</label>
    </div>


    <div>
        <button type="submit">Sign in</button>
    </div>

</EditForm>



@code {

    private string? errorMessage;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private LoginUserModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (HttpMethods.IsGet(HttpContext.Request.Method))
        {
            // Clear the existing external cookie to ensure a clean login process
            await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);
        }
    }

    public async Task LoginUser()
    {
        LoginUser.Command command = new(Input.Email, Input.Password, Input.RememberMe);

        var cmdResult = await LoginUserHandler.Handle(command, CancellationToken.None);

        // This command always succeeds, so okay to access the value (ESignInResult)).
        // This value will give us more information about the login attempt.
        ESignInResult eResult = cmdResult.Value;

        // This doesn't count login failures towards account lockout
        // To enable password failures to trigger account lockout, set lockoutOnFailure: true

        switch (eResult)
        {
            case ESignInResult.Succeeded:
                Logger.LogInformation("User [UserId] logged in.", Input.Email);
                // Going to the ReturnUrl is the default.  However, we want to go only to the home page.
                //RedirectManager.RedirectTo(ReturnUrl);
                RedirectManager.RedirectTo("/");
                break;
            case ESignInResult.IsLockedOut:
                Logger.LogWarning("User [UserId]: account locked out.", Input.Email);
                RedirectManager.RedirectTo("account/lockout");
                break;
            case ESignInResult.RequiresTwoFactor:
            // Uncomment this if we want to support two-factor authentication
            //     RedirectManager.RedirectTo(
            //         "account/login-with-2fa",
            //         new() { ["returnUrl"] = ReturnUrl, ["rememberMe"] = Input.RememberMe });
            //     break;
            case ESignInResult.IsNotAllowed:
            case ESignInResult.Failed:
            default:
                Logger.LogWarning("User [UserId]: invalid login attempt.", Input.Email);
                errorMessage = "Error: Invalid login attempt.";
                break;
        }
    }

}
